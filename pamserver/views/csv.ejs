<!DOCTYPE html>
<html>
<head>
    <title><%= title %></title>
    <link rel="stylesheet" href="/leaflet/leaflet.css"/>
    <link rel='stylesheet' href='/css/csv.css'/>
</head>
<body>
<div id="map">
</div>
<div id="sidebar">
    <div id="title">
        <h1>CartoChrono</h1>
    </div>
    <div id="legend">
        <p>Paste CSV data below:</p>
        <p>(tag, time, lat, long)</p>
    </div>
    <textarea id="csv_input">TAG0,1464208367,51.50,-0.09
TAG0,1464208377,51.51,-0.08
TAG1,1464208377,51.58,-0.02
TAG0,1464208387,51.52,-0.07
TAG1,1464208377,51.57,-0.03</textarea>
    <div id="controls">
        <fieldset>
            <legend><label>capture: <input type="checkbox" id="capture_checkbox">&nbsp;</label></legend>
            <label>tag:<input type="text" id="capture_tag" value="CAPTURED"></label>
            <p>lat/long: <span id="capture_latlng"></span></p>
        </fieldset>
        <fieldset>
            <legend>time control</legend>
            <input type="range" name="points" id="time_slider" value="50" min="0" max="100">
        </fieldset>
    </div>
</div>
<script src="/leaflet/leaflet.js"></script>
<script>
    function Fix(tag, ts, lat, lng) {
        this.tag = tag;
        var tsAsInt = parseInt(ts, 10);
        if ('' + tsAsInt === ts) { // it's an integer
            if (tsAsInt > 4000000000) { // *probably* in ms
                this.ts = tsAsInt;
            } else { // in seconds?
                this.ts = tsAsInt * 1000;
            }
        } else if (Date.parse(ts)) {
            this.ts = new Date(ts).getTime();
        } else {
            this.ts = 0; // don't break the slider control with null values
        }
        this.lat = parseFloat(lat,10);
        this.lng = parseFloat(lng,10);
    }

    Fix.prototype.asLatLng = function() {
        return [this.lat, this.lng];
    }

    function Resource(tag) {
        this.tag = tag;
        this.fixes = [];
    }

    Resource.prototype.addFix = function(fix) {
        this.fixes.push(fix);
        // keep fixes sorted by timestamp
        this.fixes.sort(function(a, b) {
            if (a.ts > b.ts) return 1;
            if (a.ts < b.ts) return -1;
            return 0;
        });
    }

    Resource.prototype.getPolyline = function() {
        var polyline = [];
        for (var i in this.fixes) {
            var fix = this.fixes[i];
            polyline.push([fix.lat, fix.lng]);
        }
        return polyline;
    }

    Resource.prototype.getFixBeforeOrAt = function(ts) {
        // resources whose first data is after ts will be show in their earliest known position
        var last = this.fixes[0];

        for (var i in this.fixes) {
            if (this.fixes[i].ts > ts) return last;
            last = this.fixes[i];
        }
        return last;
    }

    // a container for multiple resources
    function Fleet(map, time_slider) {
        this.map = map;
        this.time_slider = time_slider;
        this.resources = {};
        this.allFixes = [];

        // UI stuff
        this.multiPolyline = null;
        this.markersByTag = {};
    }

    Fleet.prototype.addFix = function(fix) {
        if (!this.resources[fix.tag]) this.resources[fix.tag] = new Resource(fix.tag);
        this.resources[fix.tag].addFix(fix);

        this.allFixes.push(fix);
        // keep fixes sorted by timestamp
        this.allFixes.sort(function(a, b) {
            if (a.ts > b.ts) return 1;
            if (a.ts < b.ts) return -1;
            return 0;
        });
    }

    Fleet.prototype.undraw = function() {
        if (this.multiPolyline != null) {
            this.map.removeLayer(this.multiPolyline);
        }
    }

    Fleet.prototype.parseCsv = function(text) {
        console.log(text);

        this.resources = {};
        this.allFixes = [];

        var lines = text.split(/[\n\r]/);
        for (var i in lines) {
            var fields = lines[i].split(',');
            if (fields.length < 4) continue;
            var tag = fields[0];
            var fix = new Fix(tag, fields[1], fields[2], fields[3]);
            this.addFix(fix);
        }
    }

    Fleet.prototype.redraw = function() {
        var polylines = [];
        for (var tag in this.resources) {
            polylines.push(this.resources[tag].getPolyline());
        }

        var latLngs = [];
        for (var i in this.allFixes) {
            var fix = this.allFixes[i];
            latLngs.push(fix.asLatLng());
        }
        var bounds = new L.LatLngBounds(latLngs);
        this.map.fitBounds(bounds);

        this.multiPolyline = L.multiPolyline(polylines);
        this.multiPolyline.addTo(this.map);

        // set slider
        if (this.allFixes.length > 1) {
            this.time_slider.setAttribute('min', this.allFixes[0].ts);
            this.time_slider.setAttribute('max', this.allFixes[this.allFixes.length - 1].ts);
            this.time_slider.setAttribute('value', this.allFixes[this.allFixes.length - 1].ts);
        }
    }

    // display markers for the fleet, as at a particular time
    Fleet.prototype.asAt = function(ts) {
        console.log('asAt', ts);
        for (var tag in this.resources) {
            var latLng = this.resources[tag].getFixBeforeOrAt(ts);
            if (!this.markersByTag[tag]) {
                this.markersByTag[tag] = L.marker(latLng);
                this.markersByTag[tag].addTo(this.map);
            } else {
                this.markersByTag[tag].setLatLng(latLng);
            }
        }
    }

    Fleet.prototype.updateCsv = function(csv) {
        this.undraw();
        this.parseCsv(csv);
        this.redraw();
    }

    function main() {
        var map = L.map('map').setView([51.505, -0.09], 11);
        var osmUrl = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
        var osmAttrib = 'Map data Â© <a href="http://openstreetmap.org">OpenStreetMap</a> contributors';
        L.tileLayer(osmUrl, {minZoom: 1, maxZoom: 18, attribution: osmAttrib}).addTo(map);

        var csv_input = document.querySelectorAll('#csv_input')[0];
        var time_slider = document.querySelectorAll('#time_slider')[0];
        var fleet = new Fleet(map, time_slider);
        csv_input.addEventListener('keyup', function(arg) {
            console.log('keyup');
            fleet.updateCsv(csv_input.value);
        });
        csv_input.addEventListener('change', function(arg) {
            console.log('change');
            fleet.updateCsv(csv_input.value);
        });
        time_slider.addEventListener('change', function(arg) {
            console.log('time_slider change', arg);
            fleet.asAt(time_slider.value);
        })


        var map_div = document.querySelectorAll('#map_div')[0];
        var capture_checkbox = document.querySelectorAll('#capture_checkbox')[0];
        capture_checkbox.checked = false;
        var capture_tag = document.querySelectorAll('#capture_tag')[0];
        var capture_latlng = document.querySelectorAll('#capture_latlng')[0];
        function handleMouseMove(event) {
            console.log('map mousemove', event.latlng);
            capture_latlng.innerHTML = event.latlng.lat.toFixed(5) + ',' + event.latlng.lng.toFixed(5);
        }
        function handleClick(event) {
            console.log('map mousemove', event.latlng);
            csv_input.value += '\n' + capture_tag.value + ',' + new Date().toISOString() + ',' + event.latlng.lat.toFixed(8) + ',' + event.latlng.lng.toFixed(8);
            csv_input.scrollTop = csv_input.scrollHeight;
            fleet.updateCsv(csv_input.value);
        }
        capture_checkbox.addEventListener('change', function(arg) {
            console.log('capture_checkbox', capture_checkbox.checked);
            if (capture_checkbox.checked) {
                map.on('mousemove', handleMouseMove);
                map.on('click', handleClick);
                map_div.style.cursor = 'crosshair';
            } else {
                map.off('mousemove', handleMouseMove);
                map.off('click', handleClick);
            }
        });

        // display data when page loads
        fleet.updateCsv(csv_input.value);
        fleet.asAt(Number.MAX_VALUE);
    }

    main();

</script>
</body>
</html>
